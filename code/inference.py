# -*- coding: utf-8 -*-
"""inference.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xQ4Oy0H7IyNQBLLrz_yVNLfLKzc4wC1O
"""

# Install YOLO and Mount Drive
!pip install ultralytics
from google.colab import drive
import os

drive.mount('/content/drive')

# Verify paths (This helps debug if files aren't found)
base_path = "/content/drive/My Drive/EdgeFleet_Assessment"
if os.path.exists(base_path):
    print(f"‚úÖ Found project folder at: {base_path}")
else:
    print(f"‚ùå ERROR: Could not find folder '{base_path}'. Please check Step 1.")

import cv2
import pandas as pd
import numpy as np
from ultralytics import YOLO
from collections import deque
import os
import glob

# --- CONFIGURATION ---
BASE_PATH = "/content/drive/My Drive/EdgeFleet_Assessment"
VIDEOS_DIR = os.path.join(BASE_PATH, "testing_videos")
MODEL_PATH = os.path.join(BASE_PATH, "best.pt")
OUTPUT_VID_DIR = os.path.join(BASE_PATH, "results")
OUTPUT_CSV_DIR = os.path.join(BASE_PATH, "annotations")

# Create output dirs if they don't exist
os.makedirs(OUTPUT_VID_DIR, exist_ok=True)
os.makedirs(OUTPUT_CSV_DIR, exist_ok=True)

class CricketBallTracker:
    def __init__(self, model_path, conf_threshold=0.25):
        self.model = YOLO(model_path)
        self.conf_threshold = conf_threshold
        self.trajectory = deque(maxlen=30)
        self.prev_centroid = None

    def interpolate_missing_frames(self, csv_data):
        df = pd.DataFrame(csv_data, columns=['frame', 'x', 'y', 'visible'])
        for i in range(1, len(df) - 1):
            if df.loc[i, 'visible'] == 0:
                prev_vis, next_vis = None, None
                # Search back 5 frames
                for j in range(i - 1, max(0, i - 6), -1):
                    if df.loc[j, 'visible'] == 1:
                        prev_vis = j
                        break
                # Search forward 5 frames
                for j in range(i + 1, min(len(df), i + 6)):
                    if df.loc[j, 'visible'] == 1:
                        next_vis = j
                        break

                if prev_vis and next_vis and (next_vis - prev_vis) <= 5:
                    alpha = (i - prev_vis) / (next_vis - prev_vis)
                    df.loc[i, 'x'] = df.loc[prev_vis, 'x'] * (1 - alpha) + df.loc[next_vis, 'x'] * alpha
                    df.loc[i, 'y'] = df.loc[prev_vis, 'y'] * (1 - alpha) + df.loc[next_vis, 'y'] * alpha
                    df.loc[i, 'visible'] = 1
        return df.values.tolist()

    def process_video(self, video_path, output_vid, output_csv, debug=False): # Added debug parameter
        cap = cv2.VideoCapture(video_path)

        # Add a check to see if the video was opened successfully
        if not cap.isOpened():
            print(f"‚ùå ERROR: Could not open video file {os.path.basename(video_path)}. Skipping...")
            return

        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        fps = cap.get(cv2.CAP_PROP_FPS)
        total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

        out = cv2.VideoWriter(output_vid, cv2.VideoWriter_fourcc(*'mp4v'), fps, (width, height))

        # Add a check if VideoWriter was initialized properly
        if not out.isOpened():
            print(f"‚ùå ERROR: Could not create video writer for {output_vid}. Skipping...")
            cap.release()
            return

        csv_data = []
        frame_idx = 0
        self.trajectory.clear()
        self.prev_centroid = None

        print(f"Processing {os.path.basename(video_path)} ({total_frames} frames)...")
        if debug:
            print("DEBUG MODE ENABLED: Visualizing all detections and selection logic.")

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret: break

            results = self.model.predict(frame, conf=self.conf_threshold, verbose=False)

            best_box = None
            max_score = -1
            all_current_boxes = [] # To store all detections for debug

            # Smart Selection Logic
            for r in results:
                for box in r.boxes:
                    x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                    conf = float(box.conf[0].cpu().numpy())

                    # Aspect Ratio Check
                    w, h = x2-x1, y2-y1
                    ar = w / h if h > 0 else 0
                    if not (0.5 < ar < 2.0): # Filtered by AR
                        if debug: # Draw aspect ratio filtered boxes in a different color
                            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), (0, 165, 255), 1) # Orange
                            cv2.putText(frame, f"AR_FILT: {conf:.2f}", (int(x1), int(y1)-5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 165, 255), 1)
                        continue

                    all_current_boxes.append((x1, y1, x2, y2, conf)) # Store valid detections

                    score = conf
                    # Proximity Boost
                    if self.prev_centroid:
                        cx_det, cy_det = (x1+x2)/2, (y1+y2)/2
                        dist = np.sqrt((cx_det-self.prev_centroid[0])**2 + (cy_det-self.prev_centroid[1])**2)
                        score = conf * np.exp(-dist/100) # Decay score with distance

                    if score > max_score:
                        max_score = score
                        best_box = [x1, y1, x2, y2, conf] # Also store conf of best_box for debug

            ball_found = False
            cx, cy = -1, -1

            if debug:
                for bx1, by1, bx2, by2, bconf in all_current_boxes:
                    # Draw all potential detections in yellow
                    cv2.rectangle(frame, (int(bx1), int(by1)), (int(bx2), int(by2)), (0, 255, 255), 1) # Yellow
                    cv2.putText(frame, f"Det:{bconf:.2f}", (int(bx1), int(by1)-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)

            if best_box:
                x1, y1, x2, y2, best_conf = best_box
                cx, cy = (x1+x2)/2, (y1+y2)/2
                self.prev_centroid = (cx, cy)
                ball_found = True

                # Draw the selected best box in green
                cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 2)
                cv2.circle(frame, (int(cx), int(cy)), 5, (0, 0, 255), -1)
                self.trajectory.append((int(cx), int(cy)))
                if debug:
                    cv2.putText(frame, f"SELECTED: {best_conf:.2f}", (int(x1), int(y1)-25), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            elif debug:
                cv2.putText(frame, "NO BALL DETECTED", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)


            # Draw Tail
            for i in range(1, len(self.trajectory)):
                cv2.line(frame, self.trajectory[i-1], self.trajectory[i], (0, 0, 255), 2)

            csv_data.append([frame_idx, round(cx, 1) if ball_found else -1, round(cy, 1) if ball_found else -1, 1 if ball_found else 0])
            out.write(frame)
            frame_idx += 1

        cap.release()
        out.release()

        # Verify video file creation
        if os.path.exists(output_vid) and os.path.getsize(output_vid) > 0:
            print(f"‚úÖ Video saved to: {output_vid} (Size: {os.path.getsize(output_vid) / (1024*1024):.2f} MB)")
        else:
            print(f"‚ùå ERROR: Video file not created or is empty: {output_vid}")

        # Apply Interpolation
        final_data = self.interpolate_missing_frames(csv_data)
        pd.DataFrame(final_data, columns=['frame', 'x', 'y', 'visible']).to_csv(output_csv, index=False)

        # Verify CSV file creation
        if os.path.exists(output_csv) and os.path.getsize(output_csv) > 0:
            print(f"‚úÖ CSV saved to: {output_csv} (Size: {os.path.getsize(output_csv) / 1024:.2f} KB)")
        else:
            print(f"‚ùå ERROR: CSV file not created or is empty: {output_csv}")

        print(f"‚úÖ Finished processing {os.path.basename(video_path)}")

# --- MAIN EXECUTION ---
if not os.path.exists(MODEL_PATH):
    print("‚ùå ERROR: best.pt not found! Please upload it to the EdgeFleet_Assessment folder.")
else:
    tracker = CricketBallTracker(MODEL_PATH)

    # Modify to search for all common video formats
    video_files = []
    for ext in ['*.mp4', '*.mov', '*.avi']:
        video_files.extend(glob.glob(os.path.join(VIDEOS_DIR, ext)))

    video_files = sorted(list(set(video_files))) # Remove duplicates and sort

    if not video_files:
        print("‚ùå No videos found! Check your testing_videos folder.")
    else:
        print(f"üöÄ Found {len(video_files)} videos. Starting batch process...")
        for video in video_files:
            v_name = os.path.splitext(os.path.basename(video))[0]
            out_vid = os.path.join(OUTPUT_VID_DIR, f"{v_name}_processed.mp4")
            out_csv = os.path.join(OUTPUT_CSV_DIR, f"{v_name}.csv")

            # Process the video in normal mode
            tracker.process_video(video, out_vid, out_csv)

        # Process the specific debug videos
        debug_videos_to_process = [
            os.path.join(VIDEOS_DIR, "2.mov"),
            os.path.join(VIDEOS_DIR, "3.mov"),
            os.path.join(VIDEOS_DIR, "4.mov")
        ]
        print(f"\nüöÄ Starting DEBUG processing for specific videos...")
        for video in debug_videos_to_process:
            if os.path.exists(video):
                v_name = os.path.splitext(os.path.basename(video))[0]
                out_vid_debug = os.path.join(OUTPUT_VID_DIR, f"{v_name}_debug_processed.mp4")
                out_csv_debug = os.path.join(OUTPUT_CSV_DIR, f"{v_name}_debug.csv") # Save debug CSV too
                tracker.process_video(video, out_vid_debug, out_csv_debug, debug=True)
            else:
                print(f"‚ùå Video not found for debugging: {video}")

        print("\nüéâ ALL PROCESSING COMPLETE! Check your Drive folder.")

import os
import glob

# Define your base path
base_path = "/content/drive/My Drive/EdgeFleet_Assessment"
video_path = os.path.join(base_path, "testing_videos")

print(f"Checking folder: {video_path}")

# 1. Check if folder exists
if not os.path.exists(video_path):
    print("‚ùå ERROR: The folder 'testing_videos' does not exist!")
    print("   Did you name it 'Testing_Videos' (capital letters)? Linux is case sensitive.")
else:
    print("‚úÖ Folder exists.")

    # 2. Check for files
    mp4_files = glob.glob(os.path.join(video_path, "*.mp4"))
    avi_files = glob.glob(os.path.join(video_path, "*.avi"))
    mov_files = glob.glob(os.path.join(video_path, "*.mov"))

    total_files = mp4_files + avi_files + mov_files

    if not total_files:
        print("‚ùå ERROR: No video files found inside 'testing_videos'!")
        print("   Make sure you uploaded them properly.")
    else:
        print(f"‚úÖ Found {len(total_files)} videos: {[os.path.basename(f) for f in total_files]}")

import cv2
import os
import glob
from ultralytics import YOLO

# --- PATHS ---
base_path = "/content/drive/My Drive/EdgeFleet_Assessment"
video_folder = os.path.join(base_path, "testing_videos")
results_folder = os.path.join(base_path, "results")
model_path = os.path.join(base_path, "best.pt")

# Ensure output folder exists
os.makedirs(results_folder, exist_ok=True)

# Find all videos
all_videos = glob.glob(os.path.join(video_folder, "*"))
if not all_videos:
    raise FileNotFoundError("No videos found! Check Step 1.")

# --- PROCESSING ALL VIDEOS ---
model = YOLO(model_path)

for video_file in all_videos:
    video_name = os.path.splitext(os.path.basename(video_file))[0]
    output_path = os.path.join(results_folder, f"{video_name}_debug_output.mp4")

    print(f"üöÄ PROCESSING: {os.path.basename(video_file)}")
    print(f"üíæ SAVING TO: {output_path}")

    try:
        # Open Video
        cap = cv2.VideoCapture(video_file)
        if not cap.isOpened():
            print(f"‚ùå ERROR: Could not open video file {os.path.basename(video_file)}. Skipping...")
            continue

        # Setup Writer (Using 'avc1' codec which is safer for Colab/MP4)
        width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        fps = cap.get(cv2.CAP_PROP_FPS)

        fourcc = cv2.VideoWriter_fourcc(*'avc1')
        out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

        frame_count = 0

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret: break

            # Simple Prediction
            results = model.predict(frame, conf=0.25, verbose=False)

            # Draw boxes
            for r in results:
                for box in r.boxes:
                    x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                    cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 4)
                    cv2.putText(frame, "BALL", (int(x1), int(y1)-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0,255,0), 2)

            out.write(frame)
            frame_count += 1

            if frame_count % 30 == 0:
                print(f"Processed {frame_count} frames for {os.path.basename(video_file)}...")

        cap.release()
        out.release()
        print(f"‚úÖ DONE processing {os.path.basename(video_file)}! Video released.\n")

    except Exception as e:
        print(f"‚ùå CRASHED during processing {os.path.basename(video_file)}: {str(e)}\n")

print("\nüéâ ALL VIDEOS PROCESSED! Check your Drive folder.")

# --- DEBUGGING SPECIFIC VIDEOS ---
# The 'tracker' object is already initialized from the previous cell.

debug_videos_to_process = [
    os.path.join(VIDEOS_DIR, "2.mov"),
    os.path.join(VIDEOS_DIR, "3.mov"),
    os.path.join(VIDEOS_DIR, "4.mov")
]

print(f"üöÄ Starting DEBUG processing for specific videos...")
for video in debug_videos_to_process:
    if os.path.exists(video):
        v_name = os.path.splitext(os.path.basename(video))[0]
        out_vid_debug = os.path.join(OUTPUT_VID_DIR, f"{v_name}_debug_processed.mp4")
        out_csv_debug = os.path.join(OUTPUT_CSV_DIR, f"{v_name}_debug.csv") # Save debug CSV too

        tracker.process_video(video, out_vid_debug, out_csv_debug, debug=True)
    else:
        print(f"‚ùå Video not found for debugging: {video}")

print("\nüéâ DEBUG PROCESSING COMPLETE! Please review the new '_debug_processed.mp4' videos.")

import os

# Define paths from previous cells
BASE_PATH = '/content/drive/My Drive/EdgeFleet_Assessment'
OUTPUT_VID_DIR = os.path.join(BASE_PATH, 'results')
OUTPUT_CSV_DIR = os.path.join(BASE_PATH, 'annotations')

print(f"--- Contents of '{OUTPUT_VID_DIR}' ---")
if os.path.exists(OUTPUT_VID_DIR) and os.listdir(OUTPUT_VID_DIR):
    for f in os.listdir(OUTPUT_VID_DIR):
        file_path = os.path.join(OUTPUT_VID_DIR, f)
        file_size = os.path.getsize(file_path) / (1024 * 1024) # Size in MB
        print(f"  - {f} (Size: {file_size:.2f} MB)")
else:
    print("  (No video files found or directory does not exist)")

print(f"\n--- Contents of '{OUTPUT_CSV_DIR}' ---")
if os.path.exists(OUTPUT_CSV_DIR) and os.listdir(OUTPUT_CSV_DIR):
    for f in os.listdir(OUTPUT_CSV_DIR):
        file_path = os.path.join(OUTPUT_CSV_DIR, f)
        file_size = os.path.getsize(file_path) / 1024 # Size in KB
        print(f"  - {f} (Size: {file_size:.2f} KB)")
else:
    print("  (No annotation CSV files found or directory does not exist)")